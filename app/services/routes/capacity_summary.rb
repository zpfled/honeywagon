module Routes
  # Aggregates truck/trailer capacity usage for a route.
  class CapacitySummary
    attr_reader :route, :usage

    def initialize(route:)
      @route = route # Store the route we are summarizing.
      @usage = aggregate_usage # Precompute usage totals once for reuse.
    end

    def trailer_usage
      {
        used: usage[:trailer_spots], # Sum of trailer spots consumed by events.
        capacity: route.trailer&.capacity_spots # Trailer capacity (nil if no trailer).
      }
    end

    def clean_water_usage
      {
        used: usage[:clean_water_gallons], # Sum of clean water gallons used by events.
        capacity: route.truck&.clean_water_capacity_gal # Truck clean water capacity (nil if no truck).
      }
    end

    def waste_usage
      {
        used: usage[:waste_gallons], # Sum of waste gallons generated by events.
        capacity: route.truck&.waste_capacity_gal # Truck waste capacity (nil if no truck).
      }
    end

    def over_capacity?
      over_capacity_dimensions.any? # True if any capacity dimension is exceeded.
    end

    def over_capacity_dimensions
      [].tap do |dims|
        dims << :trailer if over?(trailer_usage) # Flag trailer overages.
        dims << :clean_water if over?(clean_water_usage) # Flag clean water overages.
        dims << :waste if over?(waste_usage) # Flag waste overages.
      end
    end

    private

    def aggregate_usage
      events = route.service_events.not_skipped # Scope to events that should count toward usage.
      events = events.order(Arel.sql('COALESCE(route_sequence, 0)'), :created_at) # Respect route ordering for capacity rollups.
      events = events.includes(service_event_units: :unit_type).to_a unless events.loaded? # Ensure unit types are preloaded.
      preload_rental_line_items_for(events) # Preload rental items when unit counts come from orders.

      events.each_with_object({ trailer_spots: 0, clean_water_gallons: 0, waste_gallons: 0 }) do |event, memo| # Seed totals at zero.
        usage = ServiceEvents::ResourceCalculator.new(event).usage # Compute usage for this event.
        memo[:trailer_spots] += usage[:trailer_spots] # Add trailer spots.
        if event.event_type_refill?
          memo[:clean_water_gallons] = 0 # Refill resets clean water usage.
        else
          memo[:clean_water_gallons] += usage[:clean_water_gallons] # Add clean water gallons.
        end
        if event.event_type_dump?
          memo[:waste_gallons] = 0 # Dumping resets waste capacity usage.
        else
          memo[:waste_gallons] += usage[:waste_gallons] # Add waste gallons.
        end
      end
    end

    def over?(record)
      capacity = record[:capacity] # Extract capacity for the dimension.
      return false if capacity.nil? # Treat nil capacity as "no limit."

      record[:used] > capacity # Over when used exceeds capacity.
    end

    def preload_rental_line_items_for(events)
      return if events.respond_to?(:loaded?) && !events.loaded? # Only preload when events are loaded.

      orders = events.filter_map do |event| # Collect orders that need rental items preloaded.
        next unless event.order.present? # Skip events without orders.
        next unless event.service_event_units.loaded? && event.service_event_units.empty? # Only when units are absent.
        event.order # Add the order to the preload list.
      end.uniq # De-duplicate orders.
      return if orders.empty? # Nothing to preload.

      ActiveRecord::Associations::Preloader.new(records: orders, associations: { rental_line_items: :unit_type }).call # Preload rental units + types.
    end
  end
end
